# -*- coding: utf-8 -*-
"""Ethereum and FEDformer.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DOHgw1_u3EzPgYXlbUNl_5O9maVbFV-t

# –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –±—ñ–±–ª—ñ–æ—Ç–µ–∫
"""

# Commented out IPython magic to ensure Python compatibility.
!git clone https://github.com/MAZiqing/FEDformer.git
# %cd FEDformer

!pip install einops pandas scikit-image scikit-learn scipy statsmodels sympy matplotlib yfinance pywavelets

!pip install ydata-profiling

!pip install optuna

"""# –ê–Ω–∞–ª—ñ–∑ –¥–∞–Ω–∏—Ö"""

import pandas as pd

file_path = "/content/ETHUSD_1h_Binance.csv"
df = pd.read_csv(file_path)

df.head(), df.info()

df.columns = df.columns.str.lower()

rename_map = {
    'open time':'date',
    'timestamp':'date',
    'open':'Open',
    'high':'High',
    'low':'Low',
    'close':'Close',
    'volume':'Volume'
}

df = df.rename(columns=rename_map)

df['date'] = pd.to_datetime(df['date'], errors='coerce')

df_filtered = df[(df['date'] >= "2021-01-01") & (df['date'] <= "2023-12-31")]
print(len(df), "‚Üí", len(df_filtered))

df_filtered = df_filtered.sort_values("date").reset_index(drop=True)

df_filtered.head(), df_filtered.info()

df = df_filtered

drop_cols = ['quote_volume','close time','trades','taker_volume','symbol','ignore','quote asset volume','number of trades','taker buy base asset volume','taker buy quote asset volume']

df = df.drop(columns=[c for c in drop_cols if c in df.columns], errors='ignore')

df['date'] = pd.to_datetime(df['date'])
df = df.sort_values('date')

df['Returns'] = df['Close'].pct_change()
df = df.dropna()

output_path = "/content/ETH_clean_hourly.csv"
df.to_csv(output_path, index=False)

print("Dataset saved as:", output_path)
df.head()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

# 2. –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏
print("–ü–µ—Ä—à—ñ 5 —Ä—è–¥–∫—ñ–≤:")
print(df.head())
print("\n–Ü–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –ø—Ä–æ –¥–∞—Ç–∞—Å–µ—Ç:")
print(df.info())
print("\n–°—Ç–∞—Ç–∏—Å—Ç–∏—á–Ω–∏–π –æ–ø–∏—Å:")
print(df.describe())

# 3. –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –ø—Ä–æ–ø—É—Å–∫—ñ–≤
print("\n–ö—ñ–ª—å–∫—ñ—Å—Ç—å –ø—Ä–æ–ø—É—Å–∫—ñ–≤ —É –∫–æ–∂–Ω—ñ–π –∫–æ–ª–æ–Ω—Ü—ñ:")
print(df.isnull().sum())

# 4. –ü–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è –¥–∞—Ç–∏ —É datetime
df['date'] = pd.to_datetime(df['date'])

# 5. –í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è —Ü—ñ–Ω–∏ –∑–∞–∫—Ä–∏—Ç—Ç—è
plt.figure(figsize=(14,6))
plt.plot(df['date'], df['Close'], label='Close Price')
plt.title('ETH Close Price Over Time')
plt.xlabel('Date')
plt.ylabel('Price (USD)')
plt.legend()
plt.show()

# 6. –†–æ–∑–∫–ª–∞–¥ —Ç—Ä–µ–Ω–¥—É —ñ —Å–µ–∑–æ–Ω–Ω–æ—Å—Ç—ñ (–ø—Ä–∏–∫–ª–∞–¥ –¥–ª—è –¥–µ–Ω–Ω–∏—Ö –¥–∞–Ω–∏—Ö –∑ –ø–µ—Ä—ñ–æ–¥–æ–º 365)
result = seasonal_decompose(df['Close'], model='multiplicative', period=365)
result.plot()
plt.show()

# 7. –ê–≤—Ç–æ–∫–æ—Ä–µ–ª—è—Ü—ñ—è —ñ —á–∞—Å—Ç–∫–æ–≤–∞ –∞–≤—Ç–æ–∫–æ—Ä–µ–ª—è—Ü—ñ—è
plot_acf(df['Close'].dropna(), lags=50)
plot_pacf(df['Close'].dropna(), lags=50)
plt.show()

# 8. –í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è –ø—Ä–æ–ø—É—Å–∫—ñ–≤
sns.heatmap(df.isnull(), cbar=False)
plt.title('–ü—Ä–æ–ø—É—Å–∫–∏ —É –¥–∞–Ω–∏—Ö')
plt.show()

# 9. –ö–æ—Ä–µ–ª—è—Ü—ñ—è –º—ñ–∂ –æ–∑–Ω–∞–∫–∞–º–∏
corr = df[['Open','High','Low','Close','Volume']].corr()
plt.figure(figsize=(8,6))
sns.heatmap(corr, annot=True, cmap='coolwarm')
plt.title('–ö–æ—Ä–µ–ª—è—Ü—ñ—è –º—ñ–∂ –æ–∑–Ω–∞–∫–∞–º–∏')
plt.show()

# 10. –ê–Ω–∞–ª—ñ–∑ –¥–æ–±–æ–≤–∏—Ö –¥–æ—Ö–æ–¥–Ω–æ—Å—Ç–µ–π (returns)
df['Returns'] = df['Close'].pct_change()
plt.figure(figsize=(14,6))
plt.plot(df['date'], df['Returns'])
plt.title('Daily Returns')
plt.show()

import os
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

# –°—Ç–≤–æ—Ä–µ–Ω–Ω—è –ø–∞–ø–∫–∏ –¥–ª—è –≥—Ä–∞—Ñ—ñ–∫—ñ–≤
os.makedirs('plots', exist_ok=True)
df['date'] = pd.to_datetime(df['date'])

# 1. –í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è —Ü—ñ–Ω–∏ –∑–∞–∫—Ä–∏—Ç—Ç—è
plt.figure(figsize=(14,6))
plt.plot(df['date'], df['Close'], label='Close Price')
plt.title("–î–∏–Ω–∞–º—ñ–∫–∞ —Ü—ñ–Ω–∏ –∑–∞–∫—Ä–∏—Ç—Ç—è Ethereum")
plt.xlabel('–î–∞—Ç–∞')
plt.ylabel('–¶—ñ–Ω–∞ (USD)')
plt.legend()
plt.savefig('plots/close_price.png')
plt.close()

# 2. –†–æ–∑–∫–ª–∞–¥ —Ç—Ä–µ–Ω–¥—É —ñ —Å–µ–∑–æ–Ω–Ω–æ—Å—Ç—ñ
result = seasonal_decompose(df['Close'], model='multiplicative', period=365)
fig = result.plot()
fig.set_size_inches(14, 10)
fig.savefig('plots/seasonal_decompose.png')
plt.close(fig)

# 3. –ê–≤—Ç–æ–∫–æ—Ä–µ–ª—è—Ü—ñ—è
fig, ax = plt.subplots(2,1, figsize=(14,10))
plot_acf(df['Close'].dropna(), lags=50, ax=ax[0])
plot_pacf(df['Close'].dropna(), lags=50, ax=ax[1])
fig.savefig('plots/acf_pacf.png')
plt.close(fig)

# 4. –í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è –ø—Ä–æ–ø—É—Å–∫—ñ–≤
plt.figure(figsize=(14,6))
sns.heatmap(df.isnull(), cbar=False)
plt.title('Missing Data Heatmap')
plt.savefig('plots/missing_data.png')
plt.close()

df = df.dropna().reset_index(drop=True)


# 5. –ö–æ—Ä–µ–ª—è—Ü—ñ—è
plt.figure(figsize=(8,6))
sns.heatmap(df[['Open','High','Low','Close','Volume']].corr(), annot=True, cmap='coolwarm')
plt.savefig('plots/correlation.png')
plt.close()

# 6. –î–æ–±–æ–≤—ñ –¥–æ—Ö–æ–¥–Ω–æ—Å—Ç—ñ
df['Returns'] = df['Close'].pct_change()
plt.figure(figsize=(14,6))
plt.plot(df['date'], df['Returns'])
plt.title("–©–æ–¥–µ–Ω–Ω—ñ –∑–º—ñ–Ω–∏ –¥–æ—Ö—ñ–¥–Ω–æ—Å—Ç—ñ")
plt.savefig('plots/daily_returns.png')
plt.close()

print("–í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—ó –∑–±–µ—Ä–µ–∂–µ–Ω–æ –≤ –ø–∞–ø—Ü—ñ 'plots/'")

from ydata_profiling import ProfileReport

profile = ProfileReport(df, title="Crypto Data Profiling Report")
profile.to_file("crypto_data_report.html")

"""# –ó–∞–ø—É—Å–∫ Optuna"""

!python optuna_fedformer.py

"""# –¢—Ä–µ–Ω—É–≤–∞–Ω–Ω—è –∑ –Ω–∞–π–∫—Ä–∞—â–∏–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏"""

import json
import subprocess

# === 1. –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –∑–±–µ—Ä–µ–∂–µ–Ω—ñ –Ω–∞–π–∫—Ä–∞—â—ñ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ ===
with open("/content/FEDformer/results/best_params.json", "r") as f:
    best_params = json.load(f)

print("Loaded best params:")
print(best_params)

import os
os.chdir("/content/FEDformer")
print(os.getcwd())

# === 2. –§–æ—Ä–º—É—î–º–æ –∫–æ–º–∞–Ω–¥—É —Ç–∞–∫ —Å–∞–º–æ, —è–∫ —Ç–∏ –∑–∞–ø—É—Å–∫–∞–ª–∞ –≤—Ä—É—á–Ω—É ===
cmd = f"""
python run_custom.py \
--is_training 1 \
--task_id ETH \
--model FEDformer \
--version Fourier \
--mode_select random \
--modes {best_params['modes']} \
--seq_len {best_params['seq_len']} \
--label_len {best_params['label_len']} \
--pred_len {best_params['pred_len']} \
--batch_size {best_params['batch_size']} \
--train_epochs 30 \
--d_model {best_params['d_model']} \
--learning_rate {best_params['learning_rate']} \
--dropout {best_params['dropout']} \
--use_gpu True \
--data custom \
--root_path /content/ \
--data_path ETH_clean_hourly.csv \
--features M \
--target Close \
--freq h \
--do_predict

"""

print("\nüöÄ Running training command:")
print(cmd)

# === 3. –ó–∞–ø—É—Å–∫ ===
result = subprocess.run(cmd, shell=True, text=True, capture_output=True)

print("\nüìå OUTPUT:")
print(result.stdout)

print("\n‚ö†Ô∏è ERRORS (if any):")
print(result.stderr)

import pandas as pd

re = pd.read_csv("ETH_optuna_log.csv")
valid_df = re[df["value"] != float("inf")]

import subprocess

for i, row in valid_df.iterrows():
    cmd = f"""
    python run_custom.py \
    --seq_len {row['seq_len']} \
    --label_len {row['label_len']} \
    --pred_len {row['pred_len']} \
    --modes {row['modes']} \
    --d_model {row['d_model']} \
    --batch_size {row['batch_size']} \
    --learning_rate {row['learning_rate']} \
    --dropout {row['dropout']} \
    --train_epochs 50 \
    --task_id trial_{row['trial_number']}
    """
    print(f"üöÄ Training model {row['trial_number']}...")
    subprocess.run(cmd, shell=True)

import os
import glob
import numpy as np
import matplotlib.pyplot as plt

base_path = "./results/"
target_index = 0  # —è–∫—â–æ Close —ñ–Ω—à–∞ —Ñ—ñ—á–∞ ‚Äî —Å–∫–∞–∂–∏

folders = sorted(glob.glob(os.path.join(base_path, "trial_*")))

print(f"–ó–Ω–∞–π–¥–µ–Ω–æ {len(folders)} –º–æ–¥–µ–ª–µ–π.\n")

for folder in folders:
    model_name = os.path.basename(folder)

    pred_file = os.path.join(folder, "pred.npy")
    true_file = os.path.join(folder, "true.npy")
    metrics_file = os.path.join(folder, "metrics.npy")  # –Ω–æ–≤–µ

    if not (os.path.exists(pred_file) and os.path.exists(true_file)):
        print(f"‚ö†Ô∏è –ü—Ä–æ–ø—É—â–µ–Ω–æ {model_name}: –Ω–µ–º–∞—î pred.npy –∞–±–æ true.npy")
        continue

    pred = np.load(pred_file)
    true = np.load(true_file)

    # –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –º–µ—Ç—Ä–∏–∫–∏, —è–∫—â–æ —ñ—Å–Ω—É—é—Ç—å
    if os.path.exists(metrics_file):
        metrics = np.load(metrics_file)

        # –Ø–∫—â–æ —Ñ–æ—Ä–º–∞—Ç [MAE, MSE, RMSE, ...]
        if len(metrics) >= 3:
            MAE, MSE, RMSE, MAPE = metrics[:4]
        else:
            MAE = MSE = RMSE = None
    else:
        MAE = MSE = RMSE = None

    print(f"{model_name} ‚Üí pred shape: {pred.shape}, true shape: {true.shape}")

    # ===== –í–∏—Ç—è–≥—É—î–º–æ –æ—Å—Ç–∞–Ω–Ω—ñ–π –ø—Ä–æ–≥–Ω–æ–∑ =====
    pred_fixed = pred[-1, :, target_index]
    true_fixed = true[-1, :, target_index]

    # –í–∏—Ä—ñ–≤–Ω—é—î–º–æ –¥–æ–≤–∂–∏–Ω—É
    min_len = min(len(pred_fixed), len(true_fixed))
    pred_fixed = pred_fixed[:min_len]
    true_fixed = true_fixed[:min_len]

    # ===== –ü–æ–±—É–¥–æ–≤–∞ –≥—Ä–∞—Ñ—ñ–∫–∞ =====
    plt.figure(figsize=(12,6))
    plt.plot(true_fixed, label="–†–µ–∞–ª—å–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è", color="black")
    plt.plot(pred_fixed, label="–ü—Ä–æ–≥–Ω–æ–∑–æ–≤–∞–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è", color="blue")
    plt.title("–ü—Ä–æ–≥–Ω–æ–∑ FEDformer: ETH")
    plt.xlabel("–ß–∞—Å–æ–≤—ñ –∫—Ä–æ–∫–∏")
    plt.ylabel("–¶—ñ–Ω–∞")
    plt.legend()
    plt.grid()

    # ===== –î–æ–¥–∞–≤–∞–Ω–Ω—è —Ç–µ–∫—Å—Ç—É –º–µ—Ç—Ä–∏–∫ –ø—ñ–¥ –≥—Ä–∞—Ñ—ñ–∫ =====
    if MAE is not None:
        text = f"MAE: {MAE:.4f}   |   MSE: {MSE:.4f}   |   RMSE: {RMSE:.4f} |   MAPE: {MAPE:.4f}"
    else:
        text = "–ú–µ—Ç—Ä–∏–∫–∏ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ"

    plt.text(
        0.5, -0.15, text,
        ha='center', va='center',
        transform=plt.gca().transAxes,
        fontsize=11
    )

    plt.show()
    print(f"MAE: {MAE}   |   MSE: {MSE}   |   RMSE: {RMSE} |   MAPE: {MAPE:.4f}")

    print(f"‚úîÔ∏è –ü–æ–±—É–¥–æ–≤–∞–Ω–æ –≥—Ä–∞—Ñ—ñ–∫ + –º–µ—Ç—Ä–∏–∫–∏ –¥–ª—è {model_name}\n")

import numpy as np
import matplotlib.pyplot as plt

true = np.load("/content/FEDformer/results/ETH_FEDformer_random_modes8_custom_ftM_sl96_ll48_pl24_dm256_nh8_el2_dl1_df2048_fc1_ebtimeF_dtTrue_exp_0/true.npy")
pred = np.load("/content/FEDformer/results/ETH_FEDformer_random_modes8_custom_ftM_sl96_ll48_pl24_dm256_nh8_el2_dl1_df2048_fc1_ebtimeF_dtTrue_exp_0/pred.npy")

print("pred shape:", pred.shape)
print("true shape:", true.shape)

plt.figure(figsize=(12,6))
plt.plot(true[0,:,0], label='True', color='black')
plt.plot(pred[0,:,0], label='Predicted', color='blue')
plt.title("FEDformer Forecast on ETH-USD")
plt.xlabel("Time steps")
plt.ylabel("Price")
plt.legend()
plt.show()

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline

from FEDformer.utils.metrics import metric

# –ü—Ä–∏–∫–ª–∞–¥: MSE, MAE, RMSE
mae, mse, rmse, mape, mspe = metric(pred, true)

print("MAE:", mae)
print("MSE:", mse)
print("RMSE:", rmse)
print("MAPE:", mape)
print("MSPE:", mspe)

cmd = f"""
python run_custom.py \
  --is_training 1 \
  --task_id ETH_1h \
  --model FEDformer \
  --version Fourier \
  --mode_select random \
  --data custom \
  --root_path /content/ \
  --data_path ETH_clean_hourly.csv \
  --target Close \
  --freq h \
  --seq_len 336 \
  --label_len 96 \
  --pred_len 24 \
  --e_layers 3 \
  --d_layers 1 \
  --d_model 512 \
  --d_ff 1024 \
  --n_heads 8 \
  --batch_size 32 \
  --learning_rate 0.0005 \
  --dropout 0.05 \
  --train_epochs 80 \
  --patience 8 \
  --use_gpu True
"""

result = subprocess.run(cmd, shell=True, text=True, capture_output=True)

print("\nüìå OUTPUT:")
print(result.stdout)

print("\n‚ö†Ô∏è ERRORS (if any):")
print(result.stderr)

!zip -r fedformer_model.zip FEDformer